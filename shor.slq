def bitsize(n:!N) lifted {
    return ceil(log(n + 1)/log(2)) coerce !N;
}

// controlled-R gate
def R (q:B, const k:!N) {
    if q { phase(2*π/2^(k + 1)) }
    return q;
}

def find_period[size:!N] (n:!N, a:!N, q:B^size) lifted {
    for i in [0..size) {
        mod := 0:!N;
        for j in [1..2^(size - i)) {
            mod = (mod * a) % n;
        }
    }

    return q;
}

// https://whyitsso.net/physics/quantum_mechanics/QFT.html
def QFT[n:!N] (qs:B^n) {
    k := 1:!N;
    qs[0] := H(qs[0]);
    qs[1] := R(qs[1], k);
    return qs;
}

// Shor's Algorithm:
// https://tsmatz.wordpress.com/2019/06/04/quantum-integer-factorization-by-shor-period-finding-algorithm/
def shor(n:!N, a:!N) {
    size := bitsize(n) * 2;
    q := vector(size, false):B[];

    // |q> -> H -> |q>
    for i in [0..size) {
        q[i] := H(q[i]);
    }

    // |x⟩|0(=y)⟩ -> |x⟩ |a^x mod N⟩
    return (n, a, q);
}

def main(){
  qs := vector(2, 0:B);
  k := 1:!N;
  qs[0] := H(qs[0]);
  qs[1] := R(qs[1], k);
  return qs;
  //return QFT(qs);
}
